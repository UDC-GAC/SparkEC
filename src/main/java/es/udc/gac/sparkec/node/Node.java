package es.udc.gac.sparkec.node;

import java.io.Serializable;
import java.util.Arrays;

import es.udc.gac.sparkec.sequence.EagerDNASequence;
import es.udc.gac.sparkec.sequence.IDNASequence;
import scala.Tuple2;

/**
 * This class represents a Sequence, tagged with its quality value and data generated by the different filters
 * that will be applied through the execution of the system. Please note that the Node does not keep track of
 * its ID.
 */
public class Node implements Serializable {

	private static final long serialVersionUID = 1L;

	/**
	 * The DNA Sequence.
	 */
	private IDNASequence seq;
	
	/**
	 * The quality values for the DNA Sequence.
	 */
	private byte[] qv;

	/**
	 * The coverage for this DNA Sequence.
	 */
	private float coverage;

	/**
	 * The ignore information for PinchCorrect.
	 */
	private String ignP;
	
	/**
	 * The ignore information for SpreadCorrect.
	 */
	private String ignF;

	/**
	 * Whether this Node is an unique read.
	 */
	private boolean unique;

	/**
	 * Empty constructor for the Node.
	 */
	public Node() {
		this.seq = null;
		this.qv = null;
		this.coverage = 0.0f;
		this.ignP = null;
		this.ignF = null;
		this.unique = false;
	}

	/**
	 * Base constructor for the Node.
	 * @param seq The sequence of the Node
	 * @param qv The quality values of the Node
	 * @param coverage The coverage of the Node
	 */
	public Node(IDNASequence seq, byte[] qv, float coverage) {
		super();
		this.seq = seq;
		this.qv = qv;
		this.coverage = coverage;
		this.ignP = null;
		this.ignF = null;
		this.unique = false;
	}

	/**
	 * Constructor for the Node, with the ignore data.
	 * @param seq The sequence of the Node
	 * @param qv The quality values of the Node
	 * @param coverage The coverage of the Node
	 * @param ignP The ignore data for PinchCorrect of the Node
	 * @param ignF The ignore data for SpreadCorrect of the Node
	 */
	public Node(IDNASequence seq, byte[] qv, float coverage, String ignP, String ignF) {
		super();
		this.seq = seq;
		this.qv = qv;
		this.coverage = coverage;
		this.ignP = ignP;
		this.ignF = ignF;
		this.unique = false;
	}

	/**
	 * Constructor for the Node, with information specifying whether the Node was unique.
	 * @param seq The sequence of the Node
	 * @param qv The quality values of the Node
	 * @param coverage The coverage of the Node
	 * @param unique Whether this node was an unique read
	 */
	public Node(IDNASequence seq, byte[] qv, float coverage, boolean unique) {
		super();
		this.seq = seq;
		this.qv = qv;
		this.coverage = coverage;
		this.unique = unique;
	}

	/**
	 * Constructor for the Node, using all the fields.
	 * @param seq The sequence of the Node
	 * @param qv The quality values of the Node
	 * @param coverage The coverage of the Node
	 * @param ignP The ignore data for PinchCorrect of the Node
	 * @param ignF The ignore data for SpreadCorrect of the Node
	 * @param unique Whether this node was an unique read
	 */
	public Node(IDNASequence seq, byte[] qv, float coverage, String ignP, String ignF, boolean unique) {
		super();
		this.seq = seq;
		this.qv = qv;
		this.coverage = coverage;
		this.ignP = ignP;
		this.ignF = ignF;
		this.unique = unique;
	}

	/**
	 * Copy constructor for the Node.
	 * @param ori The original Node
	 */
	public Node(Node ori) {
		super();
		this.seq = ori.seq.copy();
		this.qv = Arrays.copyOf(ori.qv, ori.qv.length);
		this.coverage = ori.coverage;
		this.ignF = ori.ignF;
		this.ignP = ori.ignP;
		this.unique = ori.unique;
	}

	/**
	 * Returns the DNA Sequence of the node.
	 * @return The DNA Sequence of the node
	 */
	public IDNASequence getSeq() {
		return seq;
	}

	/**
	 * Sets the DNA Sequence of the node.
	 * @param seq The DNA Sequence of the node
	 */
	public void setSeq(IDNASequence seq) {
		this.seq = seq;
	}

	/**
	 * Returns the quality values of the Sequence.
	 * @return The quality values of the Sequence
	 */
	public byte[] getQv() {
		return qv;
	}

	/**
	 * Sets the quality values of the Sequence.
	 * @param qv The quality values of the Sequence
	 */
	public void setQv(byte[] qv) {
		this.qv = qv;
	}

	/**
	 * Returns the coverage of the Node.
	 * @return The coverage of the Node
	 */
	public float getCoverage() {
		return coverage;
	}

	/**
	 * Sets the coverage of the Node.
	 * @param coverage The coverage of the Node
	 */
	public void setCoverage(float coverage) {
		this.coverage = coverage;
	}

	/**
	 * Returns the ignore data for PinchCorrect of the Node.
	 * @return The ignore data for PinchCorrect of the Node
	 */
	public String getIgnP() {
		return ignP;
	}

	/**
	 * Sets the ignore data for PinchCorrect of the Node.
	 * @param ignP The ignore data for PinchCorrect of the Node
	 */
	public void setIgnP(String ignP) {
		this.ignP = ignP;
	}

	/**
	 * Returns the ignore data for SpreadCorrect of the Node.
	 * @return The ignore data for SpreadCorrect of the Node
	 */
	public String getIgnF() {
		return ignF;
	}

	/**
	 * Sets the ignore data for SpreadCorrect of the Node.
	 * @param ignF The ignore data for SpreadCorrect of the Node
	 */
	public void setIgnF(String ignF) {
		this.ignF = ignF;
	}

	/**
	 * Returns whether this Node is an unique read.
	 * @return Whether this Node is an unique read
	 */
	public Boolean isUnique() {
		return unique;
	}

	/**
	 * Sets whether this Node is an unique read.
	 * @param unique Whether this Node is an unique read
	 */
	public void setUnique(Boolean unique) {
		this.unique = unique;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Float.floatToIntBits(coverage);
		result = prime * result + ((ignF == null) ? 0 : ignF.hashCode());
		result = prime * result + ((ignP == null) ? 0 : ignP.hashCode());
		result = prime * result + Arrays.hashCode(qv);
		result = prime * result + ((seq == null) ? 0 : seq.hashCode());
		result = prime * result + (unique ? 1231 : 1237);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Node other = (Node) obj;
		if (Float.floatToIntBits(coverage) != Float.floatToIntBits(other.coverage))
			return false;
		if (ignF == null) {
			if (other.ignF != null) {
				return false;
			}

		} else if (!ignF.equals(other.ignF)) {
			return false;
		}
		if (ignP == null) {
			if (other.ignP != null)
				return false;
		} else if (!ignP.equals(other.ignP)) {
			return false;
		}
		if (!Arrays.equals(qv, other.qv)) {
			return false;
		}
		if (seq == null) {
			if (other.seq != null)
				return false;
		} else if (!seq.equals(other.seq)) {
			return false;
		}		
		return unique == other.unique;
	}

	@Override
	public String toString() {
		return "Node [seq=" + seq.toString() + ", qv=" + new String(qv) + ", coverage=" + coverage + ", ignP=" + ignP
				+ ", ignF=" + ignF + ", unique=" + unique + "]";
	}

	/**
	 * Converts this node to the Simple FastQ format.
	 * @param id The ID of the Node
	 * @return The node, in Simple FastQ format
	 */
	public String toSFQString(String id) {
		return id + "\t" + seq.toString() + "\t" + new String(qv);
	}

	/**
	 * Converts this node to the internal CloudEC String message representation.
	 * @param id The ID of the Node
	 * @return The node, as a CloudEC String message
	 */
	public String toCloudECString(String id) {
		StringBuilder sb = new StringBuilder(id + "\t" + EncodingUtils.MSGNODE + "\t*" + EncodingUtils.SEQ + "\t"
				+ new String(EncodingUtils.seqEncode(seq.toByteArray())) + "\t*" + EncodingUtils.QV + "\t" + new String(qv) + "\t*"
				+ EncodingUtils.COVERAGE + "\t" + coverage + "\t*" + EncodingUtils.UNIQUE + "\t" + (unique ? "1" : "0"));

		if (ignP != null) {
			sb.append("\t*" + EncodingUtils.IGNP + "\t" + ignP);
		}
		if (ignF != null) {
			sb.append("\t*" + EncodingUtils.IGNF + "\t" + ignF);
		}

		return sb.toString();
	}

	/**
	 * Parses a Node encoded in a String using the Simple FastQ format.
	 * @param nodeMsg The Node encoded in SFQ
	 * @return A tuple containing both the ID of the Node, and the Node itself
	 * @throws InvalidNodeFormatException If the format was invalid
	 */
	public static Tuple2<String, Node> fromSFQString(String nodeMsg) throws InvalidNodeFormatException {
		String[] parts = nodeMsg.split("\t");

		if (parts.length != 3) {
			throw new InvalidNodeFormatException();
		}

		Node node = new Node();
		node.setSeq(new EagerDNASequence(parts[1].getBytes()));
		node.setQv(parts[2].getBytes());
		return new Tuple2<>(parts[0], node);
	}

	/**
	 * Parses a Node encoded in the internal CloudEC String message format
	 * @param nodeMsg The Node encoded in CloudEC String message format
	 * @return A tuple containing both the ID of the Node, and the Node itself
	 * @throws InvalidNodeFormatException If the format was invalid
	 */
	public static Tuple2<String, Node> fromCloudECString(String nodeMsg) throws InvalidNodeFormatException {
		String[] parts = nodeMsg.split("\t");

		int seqIndex = -1;
		int qvIndex = -1;
		int ignPIndex = -1;
		int ignFIndex = -1;
		int coverageIndex = -1;
		int uniqueIndex = -1;

		for (int i = 1; i < parts.length - 1; i++) {
			String currentPart = parts[i];
			switch (currentPart) {
			case "*" + EncodingUtils.SEQ:
				seqIndex = i + 1;
				break;
			case "*" + EncodingUtils.QV:
				qvIndex = i + 1;
				break;
			case "*" + EncodingUtils.COVERAGE:
				coverageIndex = i + 1;
				break;
			case "*" + EncodingUtils.IGNF:
				ignFIndex = i + 1;
				break;
			case "*" + EncodingUtils.IGNP:
				ignPIndex = i + 1;
				break;
			case "*" + EncodingUtils.UNIQUE:
				uniqueIndex = i + 1;
				break;
			default:
				break;
			}
		}

		if ((seqIndex == -1) || (qvIndex == -1) || (parts.length < 5)) {
			throw new InvalidNodeFormatException();
		}

		Node node = new Node();

		node.setSeq(new EagerDNASequence(EncodingUtils.seqDecode(parts[seqIndex].getBytes())));
		node.setQv(parts[qvIndex].getBytes());
		if (coverageIndex != -1) {
			node.setCoverage(Float.parseFloat(parts[coverageIndex]));
		}
		if (ignPIndex != -1) {
			node.setIgnP(parts[ignPIndex]);
		}
		if (ignFIndex != -1) {
			node.setIgnF(parts[ignFIndex]);
		}

		if (uniqueIndex != -1) {
			node.setUnique(parts[uniqueIndex].equals("1"));
		}

		return new Tuple2<>(parts[0], node);
	}

}

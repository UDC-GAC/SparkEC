package es.udc.gac.sparkec.test.spreadcorrect;

import static com.holdenkarau.spark.testing.JavaRDDComparisons.assertRDDEquals;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.function.Function;
import org.junit.Before;
import org.junit.Test;

import es.udc.gac.sparkec.node.Node;
import es.udc.gac.sparkec.spreadcorrect.Recommendation;
import es.udc.gac.sparkec.spreadcorrect.SpreadCorrectRecommend;
import es.udc.gac.sparkec.test.utils.DataSetNotFoundException;
import es.udc.gac.sparkec.test.utils.PhaseTest;
import scala.Tuple2;

public class SpreadCorrectRecommendTest extends PhaseTest {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private SpreadCorrectRecommend task;

	public SpreadCorrectRecommendTest() {
		super("spreadcorrect_Recommend", new String[] { "in", "out" });
	}

	@Before
	@Override
	public void setUp() throws Exception {
		super.setUp();
		this.task = new SpreadCorrectRecommend(this.config.getJavaSparkContext(), this.config.getK(),
				this.config.getArm(), this.config.getHeight(), this.config.getScheme(), this.config.getStackMax(),
				this.config.getStackMin());
	}

	/**
	 * Test of run method, of class SpreadCorrectRecommend.
	 * 
	 * @throws es.udc.gac.sparkec.test.utils.DataSetNotFoundException
	 */
	@Test
	public void testRun() throws DataSetNotFoundException {
		JavaPairRDD<String, Node> in = this.getDataset("in").mapToPair(Node::fromCloudECString);
		JavaRDD<String> expectedOut = this.getDataset("out");
		
		Tuple2<JavaPairRDD<Long, Node>, JavaPairRDD<Long, String>> inProcessed;
		inProcessed = this.splitWithMapping(in);

		JavaPairRDD<Long, Iterable<Recommendation>> out;
		out = this.task.run(inProcessed._1, this.getSplitStrategy());

		JavaRDD<Tuple2<String, Iterable<Recommendation>>> outProcessed;
		outProcessed =  this.joinWithMapping(out, inProcessed._2).map(e -> e);

		/**
		 * Since the original data generated by CloudEC was not unique by each node, we
		 * will need to join all those lines into one in order to be able to compare it
		 * with our result dataset. In order to achieve this, we will begin by splitting
		 * the expected output in nodeID + the remaining fields.
		 */
		JavaPairRDD<String, String> expectedOutSplit;
		expectedOutSplit = expectedOut.mapToPair(e -> {
			String[] parts = e.split("\t", 2);

			return new Tuple2<>(parts[0], parts[1]);
		});

		/**
		 * Then, we group all the lines by their NodeId.
		 */
		JavaPairRDD<String, Iterable<String>> expectedOutGrouped;
		expectedOutGrouped = expectedOutSplit.groupByKey();

		/**
		 * And finally, we join the Strings with the encoded recommendation into a
		 * single one.
		 */
		JavaRDD<Tuple2<String, Iterable<Recommendation>>> expectedOutProcessed;
		expectedOutProcessed = expectedOutGrouped.map(e -> {

			List<Recommendation> result = new LinkedList<>();
			Iterator<String> it = e._2.iterator();
			while (it.hasNext()) {
				result.addAll(SpreadCorrectTestUtils.decodeRecommend(it.next().split("\t", 2)[1]));
			}

			result.sort((a, b) -> Integer.compare(a.getPos(), b.getPos()));

			return new Tuple2<>(e._1, result);
		});

		Function<Tuple2<String, Iterable<Recommendation>>, Tuple2<String, List<Recommendation>>> mapToList;
		mapToList = e -> {
			List<Recommendation> list = new ArrayList<>();

			Iterator<Recommendation> it = e._2.iterator();
			while (it.hasNext()) {
				list.add(it.next());
			}

			list.sort((a, b) -> {
				int compare = Integer.compare(a.getPos(), b.getPos());
				if (compare != 0) {
					return compare;
				}

				if (a.getBase() < b.getBase()) {
					return -1;
				} else if (a.getBase() == b.getBase()) {
					return 0;
				} else {
					return 1;
				}
			});

			return new Tuple2<>(e._1, list);
		};

		JavaRDD<Tuple2<String, List<Recommendation>>> listOut;
		listOut = outProcessed.map(mapToList);

		JavaRDD<Tuple2<String, List<Recommendation>>> listExpectedOut;
		listExpectedOut = expectedOutProcessed.map(mapToList);

		assertRDDEquals(listOut, listExpectedOut);
	}

}
